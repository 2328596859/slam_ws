# serial_communication

## 简介

本模块用于实现智科云机器人 x86 与主控板之间的串口通信，基于 robot-ctrl-bus 协议，适用于 ROS 环境下的数据收发。

## 通信协议说明

- **协议类型**：串行通信协议，基于 RS232，采用小端传输
- **波特率**：115200
- **数据位**：8
- **校验位**：None
- **停止位**：1
- **流控**：None

### 通信角色

- **Master（宿主）**：始终首先发送数据
- **Slave（从机）**：接收后回应

每次通信为一问一答，Master 发送请求，Slave 回复应答。

## 数据包结构

| 字段      | 类型      | 说明                   |
| --------- | --------- | ---------------------- |
| Flag      | uint8_t   | 帧头，0xA5 或 0x5A     |
| Datelen   | uint8_t/uint16_t | 数据包长度           |
| CMD1      | uint8_t   | 功能索引/反馈类型      |
| CMD2      | uint8_t   | 具体功能（请求包）     |
| DATE      | uint8_t[n]| 有效数据               |
| Checksum  | uint8_t   | 校验和                 |

- **标准帧**：Flag=0xA5，Datelen=1字节，适用于长度<255
- **长帧**：Flag=0x5A，Datelen=2字节，适用于长度≥255

**校验和**：Checksum = Flag ^ Datelen ^ CMD1 ^ CMD2 ^ DATE[0] ^ ... ^ DATE[N]

### CMD1 定义（请求包）

| CMD1  | 含义                   |
| ----- | ---------------------- |
| 0x00  | 同步帧                 |
| 0x01  | ECHO帧                 |
| 0x02-0x0F | 保留               |
| 0x55  | CMD2 具体功能索引      |

### CMD1 定义（应答包）

| CMD1  | 含义                   |
| ----- | ---------------------- |
| 0x00  | 同步帧应答             |
| 0x01  | ECHO帧应答             |
| 0x02  | OK，执行成功           |
| 0x03  | Error，执行出错        |
| 0xFF  | Invalid，数据包错误    |

### 错误码

| 错误码   | 含义                           |
| ------- | ------------------------------ |
| 0x40    | 校验和不匹配                   |
| 0x20    | 数据包长度超限                 |
| 0x10    | 信道未同步                     |
| 0x8000  | 不支持的 CMD                   |
| 0x8001  | 格式类错误                     |
| 0x8002  | 操作类错误                     |

## 常用指令示例

### 升降杆控制（x86 → 主控板）

| 字段    | 示例值      | 说明                  |
| ------- | ----------- | --------------------- |
| Flag    | 0xA5        | 帧头                  |
| Datelen | 0x02        | 数据长度              |
| CMD1    | 0x55        | 功能索引              |
| CMD2    | 0x20        | 升降杆控制            |
| DATE[0] | 0x00/0x01   | 0x00上升，0x01下降    |
| DATE[1] | 0xXX        | 上升/下降距离（mm）   |
| CHKSUM  | 0xXX        | 校验和                |

### 云台控制（x86 → 主控板）

| 字段    | 示例值      | 说明                  |
| ------- | ----------- | --------------------- |
| Flag    | 0xA5        | 帧头                  |
| Datelen | 0x02        | 数据长度              |
| CMD1    | 0x55        | 功能索引              |
| CMD2    | 0x21        | 云台控制              |
| DATE[0] | 0x00~0x03   | 0x00左，0x01右，0x02上仰，0x03下仰 |
| DATE[1] | 0xXX        | 旋转角度              |
| CHKSUM  | 0xXX        | 校验和                |

### 请求烟雾温湿度数据（x86 → 主控板）

| 字段    | 示例值      | 说明                  |
| ------- | ----------- | --------------------- |
| Flag    | 0xA5        | 帧头                  |
| Datelen | 0x02        | 数据长度              |
| CMD1    | 0x55        | 功能索引              |
| CMD2    | 0x22        | 请求数据              |
| CHKSUM  | 0xXX        | 校验和                |

#### 主控板响应

| 字段      | 说明                        |
| --------- | --------------------------- |
| DATA[0~1] | 烟雾数据（需转为十进制）    |
| DATA[2~3] | 温度数据（十进制/100）      |
| DATA[4~5] | 湿度数据（十进制/100）      |

## 如何模拟进行测试

1. **使用虚拟串口工具（推荐 socat 或 com0com）**
   - 在 Linux 下可用 `socat` 创建一对虚拟串口：
     ```bash
     sudo apt-get install socat
     socat -d -d PTY,link=/tmp/ttyV0,raw,echo=0 PTY,link=/tmp/ttyV1,raw,echo=0
     ```
   - `/tmp/ttyV0` 和 `/tmp/ttyV1` 互为虚拟串口，可分别作为主控和从控端。

2. **运行你的 ROS 节点**
   - 修改节点参数，将串口端口设置为 `/tmp/ttyV0` 或 `/tmp/ttyV1`。
   - 启动节点：
     ```bash
     rosrun serial_communication serial_communication_node
     ```

3. **用串口调试助手或自写 Python 脚本模拟另一端**
   - 例如用 Python 向 `/tmp/ttyV1` 发送协议帧，或监听节点发出的数据。
   - 示例 Python 发送代码（需安装 pyserial）：
     ```python
     import serial
     ser = serial.Serial('/tmp/ttyV1', 115200)
     frame = bytes([0xA5, 0x00, 0x02, 0x55, 0x20, 0xF2])  # 示例帧
     ser.write(frame)
     ```

4. **查看 ROS 日志和话题**
   - 订阅 `serial_msg` 话题，验证节点是否正确解析和发布串口数据。

5. **调试建议**
   - 可在两个终端分别运行节点和模拟端，便于观察收发效果。
   - 若需自动化测试，可编写脚本批量发送不同协议帧。

